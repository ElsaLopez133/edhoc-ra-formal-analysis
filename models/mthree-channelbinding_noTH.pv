const g:bitstring.
free att:channel.
free sComp:bitstring.
free sSignature1:bitstring.
free sfive:bitstring.
free sfour:bitstring.
free snull:bitstring.
free srep:bitstring.
free sseven:bitstring.
free ssix:bitstring.
free sthree:bitstring.
free stone:bitstring.
free stwo:bitstring.
free stzero:bitstring.
fun aeadenc(bitstring,bitstring,bitstring,bitstring):bitstring.
fun const_cred():bitstring.
fun const_grp():bitstring.
fun edhoc_kdf(bitstring,bitstring,bitstring,bitstring):bitstring.
fun edhoc_mac_length():bitstring.
fun encxor(bitstring,bitstring):bitstring.
fun error_code_one():bitstring.
fun error_code_two():bitstring.
fun exp(bitstring,bitstring):bitstring.
fun fst(bitstring):bitstring.
fun hash(bitstring):bitstring.
fun hash_length():bitstring.
fun hkdfexpand(bitstring,bitstring):bitstring.
fun hkdfextract(bitstring,bitstring):bitstring.
fun id(bitstring,bitstring):bitstring.
fun id_att(bitstring,bitstring):bitstring.
fun iv_length():bitstring.
fun key_length():bitstring.
fun length():bitstring.
fun method_three():bitstring.
fun pair(bitstring,bitstring):bitstring.
fun pk(bitstring):bitstring.
fun plaintext_length():bitstring.
fun sign(bitstring,bitstring,bitstring):bitstring.
fun sigtrue():bitstring.
fun snd(bitstring):bitstring.
fun suitesIConst():bitstring.
fun suitesRConst():bitstring.
fun wrap(bitstring):bitstring.
event eAcceptI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptRData(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAcceptRRA(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAccept_Att(bitstring,bitstring,bitstring,bitstring).
event eAttGeneratedI(bitstring,bitstring,bitstring,bitstring).
event eAtt_generate(bitstring,bitstring,bitstring,bitstring).
event eAtt_good(bitstring,bitstring,bitstring,bitstring).
event eAttestationAcceptedR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eAttestationGeneratedI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eCompromise(bitstring).
event eDerivedIShared(bitstring,bitstring).
event eDerivedIdR(bitstring,bitstring).
event eDerivedR(bitstring,bitstring,bitstring,bitstring,bitstring).
event eDerivedRShared(bitstring,bitstring).
event eFinishR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eHonest(bitstring).
event eHonestNonce(bitstring).
event eLeak(bitstring).
event eLeakAttKey(bitstring).
event eLeakSessionKey(bitstring).
event eLeakShare(bitstring).
event eMethodOk(bitstring).
event eSecretsI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eSecretsR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eSendRData(bitstring,bitstring,bitstring).
event eSentByI(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eShare(bitstring).
event eShareLT(bitstring).
event eTHIShared(bitstring,bitstring).
event eTHRShared(bitstring,bitstring).
event eVerifiedNonceR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event eVerifiedSignatureR(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
equation forall a:bitstring,b:bitstring; exp( exp(g,a),b) = exp(exp(g,b),a).
equation forall x_1:bitstring, x_2:bitstring;   fst((x_1, x_2)) = x_1.
equation forall x_1:bitstring, x_2:bitstring;   snd((x_1, x_2)) = x_2.
reduc forall ad:bitstring, k:bitstring, m:bitstring, r:bitstring;   aeaddec(aeadenc(m, r, k, ad), k, ad) = m.
reduc forall m:bitstring, r:bitstring, sk:bitstring;   revealsign(sign(m, r, sk)) = m.
reduc forall m:bitstring, r:bitstring, sk:bitstring;   verify(sign(m, r, sk), m, pk(sk)) = sigtrue.
reduc forall m:bitstring, x:bitstring;   decxor(encxor(m, x), x) = m.
reduc forall x:bitstring, y:bitstring;   get_DH_cred(id(x, y)) = y.
reduc forall x:bitstring, y:bitstring;   get_att_key(id_att(x, y)) = y.
reduc forall x:bitstring, y:bitstring;   get_meas(id_att(x, y)) = x.
reduc forall x:bitstring, y:bitstring;   get_sig_cred(id(x, y)) = x.
reduc forall x:bitstring;   check_cred(x) = const_cred.
reduc forall x:bitstring;   check_grp(x) = const_grp.
set preciseActions=true.
(* set simplifyProcess = false.
set reconstructTrace = false. *)


(* can be used to restrict methods *)
restriction m:bitstring; event(eMethodOk(m)) ==> m=method_three.

(*ChannelBinding_RelayAttack*)
query ak:bitstring, cidI:bitstring, cidR:bitstring, gx:bitstring,
      gxy:bitstring, gxy1:bitstring, gxy2:bitstring, gy:bitstring,
      id_att:bitstring, nonce:bitstring, pkI:bitstring, pkI1:bitstring,
      pkI2:bitstring, pkR:bitstring, pkR1:bitstring, pkR2:bitstring,
      pk_attkey:bitstring, sig:bitstring, th3:bitstring, th31:bitstring,
      th32:bitstring, i:time, j:time, t:time, pkI_1:bitstring, pkR_1:bitstring;
 (event(eAttestationAcceptedR( cidR, pkI, pkR, nonce, sig, gxy, gx, gy,
                               th3, pk_attkey, id_att
        ))@j) ==>
 (((((event(eSentByI( cidI, pkI, pkR, nonce, sig, gxy, gx, gy, th3, ak,
                      pk_attkey, id_att
            ))@i) &&
     (i < j)) ||
    (event(eLeakAttKey( ak ))@t)) ||
   (event(eCompromise( pkI_1 ))@t)) ||
  (event(eCompromise( pkR_1 ))@t))
.
let MakeDEO()=
    0.
let ContactJudgeFromI(ID_CRED_R_2:bitstring, TH_2J_2:bitstring,
                      pkR_2:bitstring, EAD_2_2:bitstring, MAC_2J_2:bitstring,
                      SIGNATURE_or_MAC_2_2:bitstring)=
    0.
let ContactJudgeFromR(ID_CRED_I_2:bitstring, TH_3J_2:bitstring,
                      pkI_2:bitstring, EAD_3_2:bitstring, MAC_3J_2:bitstring,
                      SIGNATURE_or_MAC_3_2:bitstring)=
    0.
let CompromiseShare(s_2:bitstring)=
    event eLeakShare( snull ).
let leakSKey(key_2:bitstring)=
    event eLeakSessionKey( snull ).
let JudgeR()=
    0.
let JudgeI()=
    0.
let I(cid_2:bitstring, skI_2:bitstring, I_2:bitstring, ak_2:bitstring,
      measurement_2:bitstring, ID_CRED_R_2:bitstring)=
    in(att,(method_2:bitstring, (suitesI_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring))));
    event eMethodOk( method_2 );
    new X_2:bitstring;
    event eShare( X_2 );
    ((CompromiseShare(X_2))
   | (let CRED_I_2:bitstring=pk(skI_2) in
      let ID_CRED_I_2:bitstring=id(CRED_I_2, exp(g, I_2)) in
      let ID_CRED_Att_2:bitstring=id_att(hash(measurement_2), pk(ak_2)) in
      let G_X_2:bitstring=exp(g, X_2) in
      let G_I_2:bitstring=exp(g, I_2) in
      let m1_2:bitstring=(method_2, (suitesI_2, (G_X_2, (C_I_2, EAD_1_2)))) in
      out(att,m1_2);
      in(att,m2_2:bitstring);
      let (G_Y_2:bitstring, CIPHERTEXT_2_2:bitstring)=m2_2 in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let G_YX_2:bitstring=exp(G_Y_2, X_2) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_YX_2) in
      let KEYSTREAM_2_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                            plaintext_length) in
      let plaintext_2_2:bitstring=decxor(CIPHERTEXT_2_2, KEYSTREAM_2_2) in
      let (C_R_2:bitstring, (=ID_CRED_R_2, (SIGNATURE_or_MAC_2_2:bitstring, EAD_2_2:bitstring)))=plaintext_2_2 in
      let nonceR_2:bitstring=EAD_2_2 in
      if ID_CRED_I_2 = check_cred(ID_CRED_R_2) then
          (0)
      else
          (if method_2 = method_three then
               (let pkR_2:bitstring=get_DH_cred(ID_CRED_R_2) in
                let pkI_2:bitstring=get_DH_cred(ID_CRED_I_2) in
                let pkRX_2:bitstring=exp(pkR_2, X_2) in
                let SALT_3e2m_2:bitstring=edhoc_kdf(PRK_2e_2, stone, TH_2_2,
                                                    hash_length) in
                let PRK_3e2m_2:bitstring=hkdfextract(SALT_3e2m_2, pkRX_2) in
                event eDerivedIShared( pkI_2, G_YX_2 );
                let MAC_2_2:bitstring=edhoc_kdf(PRK_3e2m_2, stwo,
                                                (ID_CRED_R_2, (TH_2_2, (pkR_2, EAD_2_2))), hash_length) in
                if SIGNATURE_or_MAC_2_2 = MAC_2_2 then
                    (let measurement_hash_2:bitstring=hash(measurement_2) in
                     let TH_3_2:bitstring=hash((wrap(TH_2_2), (plaintext_2_2, pkR_2))) in
                     let signature_2:bitstring=sign((sSignature1, (ID_CRED_Att_2, (nonceR_2, measurement_hash_2))),
                                                    srep, ak_2) in
                     let EAD_3_2:bitstring=(ID_CRED_Att_2, (nonceR_2, signature_2)) in
                     event eAttestationGeneratedI( cid_2, pkI_2, pkR_2, nonceR_2, signature_2,
                                                   ak_2, X_2, G_YX_2
                           );
                     event eAttGeneratedI( cid_2, ID_CRED_Att_2, nonceR_2, TH_3_2 );
                     event eAtt_generate( nonceR_2, TH_3_2, G_YX_2, pk(ak_2) );
                     event eTHIShared( pkI_2, TH_3_2 );
                     let G_YI_2:bitstring=exp(G_Y_2, I_2) in
                     let SALT_4e3m_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfive, TH_3_2,
                                                         hash_length) in
                     let PRK_4e3m_2:bitstring=hkdfextract(SALT_4e3m_2, G_YI_2) in
                     let MAC_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, ssix,
                                                     (ID_CRED_I_2, (TH_3_2, (pkI_2, EAD_3_2))),
                                                     hash_length) in
                     let SIGNATURE_or_MAC_3_2:bitstring=MAC_3_2 in
                     let K_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthree, TH_3_2, key_length) in
                     let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfour, TH_3_2, iv_length) in
                     let plaintext_3_2:bitstring=(ID_CRED_I_2, (SIGNATURE_or_MAC_3_2, EAD_3_2)) in
                     let m3_2:bitstring=aeadenc(plaintext_3_2, srep, K_3_2, IV_3_2) in
                     event eSentByI( cid_2, pkI_2, pkR_2, nonceR_2, signature_2, G_YX_2,
                                     G_X_2, G_Y_2, TH_3_2, ak_2, pk(ak_2), ID_CRED_Att_2
                           );
                     let TH_4_2:bitstring=hash((wrap(TH_3_2), (plaintext_3_2, pkI_2))) in
                     let PRK_out_2:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                                       hash_length) in
                     event eAcceptI( cid_2, method_three, pkI_2, pkR_2, PRK_3e2m_2,
                                     PRK_4e3m_2, PRK_out_2, X_2, G_Y_2
                           );
                     event eSecretsI( cid_2, method_three, pkI_2, pkR_2, PRK_2e_2, PRK_3e2m_2,
                                      PRK_4e3m_2, PRK_out_2, KEYSTREAM_2_2, K_3_2, IV_3_2, X_2, G_Y_2
                           );
                     out(att,m3_2)))))).
let R(cid_2:bitstring, skR_2:bitstring, R_2:bitstring,
      ID_CRED_Att_2:bitstring)=
    in(att,(C_R_2:bitstring, suitesR_2:bitstring));
    in(att,(method_2:bitstring, (suitesI_2:bitstring, (G_X_2:bitstring, (C_I_2:bitstring, EAD_1_2:bitstring)))));
    event eMethodOk( method_2 );
    let m1_2:bitstring=(method_2, (suitesI_2, (G_X_2, (C_I_2, EAD_1_2)))) in
    new Y_2:bitstring;
    event eShare( Y_2 );
    let G_R_2:bitstring=exp(g, R_2) in
    let G_Y_2:bitstring=exp(g, Y_2) in
    let G_XY_2:bitstring=exp(G_X_2, Y_2) in
    ((CompromiseShare(Y_2))
   | (let CRED_R_2:bitstring=pk(skR_2) in
      let ID_CRED_R_2:bitstring=id(CRED_R_2, G_R_2) in
      let TH_1_2:bitstring=hash((wrap(method_2), (wrap(suitesI_2), (wrap(G_X_2), (wrap(C_I_2), EAD_1_2))))) in
      let TH_2_2:bitstring=hash((wrap(G_Y_2), wrap(TH_1_2))) in
      let PRK_2e_2:bitstring=hkdfextract(TH_2_2, G_XY_2) in
      if method_2 = method_three then
          (new nonceR_2:bitstring;
           event eHonestNonce( nonceR_2 );
           let EAD_2_2:bitstring=nonceR_2 in
           let pkR_2:bitstring=get_DH_cred(ID_CRED_R_2) in
           let G_XR_2:bitstring=exp(G_X_2, R_2) in
           let SALT_3e2m_2:bitstring=edhoc_kdf(PRK_2e_2, stone, TH_2_2,
                                               hash_length) in
           let PRK_3e2m_2:bitstring=hkdfextract(SALT_3e2m_2, G_XR_2) in
           let MAC_2_2:bitstring=edhoc_kdf(PRK_3e2m_2, stwo,
                                           (ID_CRED_R_2, (TH_2_2, (pkR_2, EAD_2_2))), hash_length) in
           let SIGNATURE_or_MAC_2_2:bitstring=MAC_2_2 in
           let plaintext_2_2:bitstring=(C_R_2, (ID_CRED_R_2, (SIGNATURE_or_MAC_2_2, EAD_2_2))) in
           let KEYSTREAM_2_2:bitstring=edhoc_kdf(PRK_2e_2, stzero, TH_2_2,
                                                 plaintext_length) in
           event eDerivedR( cid_2, pkR_2, PRK_3e2m_2, Y_2, G_X_2 );
           event eTHRShared( pkR_2, TH_2_2 );
           event eDerivedRShared( pkR_2, G_XY_2 );
           event eDerivedIdR( ID_CRED_R_2, PRK_3e2m_2 );
           let m2_2:bitstring=(G_Y_2, (encxor(plaintext_2_2,
                                              KEYSTREAM_2_2), C_R_2)) in
           event eSendRData( method_three, pkR_2,
                             (TH_2_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (m1_2, plaintext_2_2)))))
                 );
           out(att,m2_2);
           in(att,CIPHERTEXT_3_2:bitstring);
           let TH_3_2:bitstring=hash((wrap(TH_2_2), (plaintext_2_2, pkR_2))) in
           let K_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sthree, TH_3_2, key_length) in
           let IV_3_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfour, TH_3_2, iv_length) in
           let plaintext_3_2:bitstring=aeaddec(CIPHERTEXT_3_2, K_3_2, IV_3_2) in
           let (ID_CRED_I_2:bitstring, (SIGNATURE_or_MAC_3_2:bitstring, EAD_3_2:bitstring))=plaintext_3_2 in
           let pkI_2:bitstring=get_DH_cred(ID_CRED_I_2) in
           let TH_4_2:bitstring=hash((wrap(TH_3_2), (plaintext_3_2, pkI_2))) in
           let pkIY_2:bitstring=exp(pkI_2, Y_2) in
           let SALT_4e3m_2:bitstring=edhoc_kdf(PRK_3e2m_2, sfive, TH_3_2,
                                               hash_length) in
           let PRK_4e3m_2:bitstring=hkdfextract(SALT_4e3m_2, pkIY_2) in
           let MAC_3_2:bitstring=edhoc_kdf(PRK_4e3m_2, ssix,
                                           (ID_CRED_I_2, (TH_3_2, (pkI_2, EAD_3_2))), hash_length) in
           if SIGNATURE_or_MAC_3_2 = MAC_3_2 then
               (if ID_CRED_R_2 = check_cred(ID_CRED_I_2) then
                    (0)
                else
                    (let (=ID_CRED_Att_2, (nonceR_in_2:bitstring, signature_in_2:bitstring))=EAD_3_2 in
                     let measurement_hash_R_2:bitstring=get_meas(ID_CRED_Att_2) in
                     let pk_attkey_2:bitstring=get_att_key(ID_CRED_Att_2) in
                     if verify(signature_in_2,
                               (sSignature1, (ID_CRED_Att_2, (nonceR_in_2, measurement_hash_R_2))),
                               pk_attkey_2) =
                        sigtrue then
                         (event eVerifiedSignatureR( cid_2, pkI_2, pkR_2, nonceR_in_2,
                                                     signature_in_2, Y_2, G_XY_2
                                );
                          if nonceR_2 = nonceR_in_2 then
                              (event eVerifiedNonceR( cid_2, method_three, pkI_2, pkR_2,
                                                      signature_in_2, nonceR_in_2, Y_2, G_XY_2, pk_attkey_2
                                     );
                               event eAttestationAcceptedR( cid_2, pkI_2, pkR_2, nonceR_in_2,
                                                            signature_in_2, G_XY_2, G_X_2, G_Y_2, TH_3_2,
                                                            pk_attkey_2, ID_CRED_Att_2
                                     );
                               event eAccept_Att( cid_2, ID_CRED_Att_2, nonceR_in_2, TH_3_2 );
                               event eAtt_good( nonceR_in_2, TH_3_2, G_XY_2, pk_attkey_2 );
                               let PRK_out_3:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                                                 hash_length) in
                               event eAcceptR( cid_2, method_three, pkI_2, pkR_2, PRK_4e3m_2, PRK_out_3,
                                               Y_2, G_X_2
                                     );
                               event eAcceptRRA( cid_2, method_three, pkI_2, pkR_2, PRK_4e3m_2,
                                                 PRK_out_3, Y_2, G_X_2, G_XY_2
                                     );
                               event eFinishR( cid_2, method_three, pkI_2, pkR_2, G_XY_2, Y_2,
                                               nonceR_in_2, signature_in_2, pk_attkey_2
                                     )))
                     else
                         (let PRK_out_4:bitstring=edhoc_kdf(PRK_4e3m_2, sseven, TH_4_2,
                                                            hash_length) in
                          event eAcceptR( cid_2, method_three, pkI_2, pkR_2, PRK_4e3m_2, PRK_out_4,
                                          Y_2, G_X_2
                                );
                          event eSecretsR( cid_2, method_three, pkI_2, pkR_2, PRK_2e_2, PRK_3e2m_2,
                                           PRK_4e3m_2, PRK_out_4, KEYSTREAM_2_2, K_3_2, IV_3_2, Y_2, G_X_2
                                );
                          event eAcceptRData( PRK_out_4, method_three, pkI_2, pkR_2, Y_2, G_X_2,
                                              (TH_2_2, (TH_3_2, (TH_4_2, (suitesI_2, (EAD_1_2, (EAD_2_2, (EAD_3_2, (m1_2, (plaintext_2_2, plaintext_3_2)))))))))
                                ))))))).
let compromise(sk_2:bitstring)=
    in(att,=sComp);
    event eCompromise( pk(sk_2) );
    out(att,sk_2).
let compromiseDH(k_2:bitstring)=
    in(att,=sComp);
    event eCompromise( exp(g, k_2) );
    event eLeak( k_2 );
    out(att,k_2).
let LeakAttKey(ak_2:bitstring)=
    in(att,=sComp);
    event eLeakAttKey( pk(ak_2) );
    out(att,ak_2).


process
    ((((((!
          (0))
       | (!
          (0))))
     | (!
        (0))))
   | (!
      (new sk_2:bitstring;
       new ltdh_2:bitstring;
       new computerId_2:bitstring;
       new ak_2:bitstring;
       new measurement_2:bitstring;
       let idd_2:bitstring=id(pk(sk_2), exp(g, ltdh_2)) in
       out(att,(idd_2, (pk(sk_2), exp(g, ltdh_2))));
       let idd_att_2:bitstring=id_att(hash(measurement_2), pk(ak_2)) in
       event eShareLT( ltdh_2 );
       event eHonest( pk(sk_2) );
       event eHonest( exp(g, ltdh_2) );
       event eHonest( pk(ak_2) );
       event eHonest( hash(measurement_2) );
       ((((((((!
               (in(att,cred_2:bitstring);
                I(computerId_2, sk_2, ltdh_2, ak_2, measurement_2, cred_2)))
            | (!
               (R(computerId_2, sk_2, ltdh_2, idd_att_2)))))
          | (compromise(sk_2))))
        | (compromiseDH(ltdh_2))))
      | (LeakAttKey(ak_2))))))

(*
WARNING: the following wellformedness checks failed!

Inexistant lemma actions
========================

  lemma `ChannelBinding_RelayAttack' references action 
    fact "AttestationAcceptedR" (arity 11, Linear) 
  but no rule has such an action.
  
  lemma `ChannelBinding_RelayAttack' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `ChannelBinding_RelayAttack' references action 
    fact "LeakAttKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `ChannelBinding_RelayAttack' references action 
    fact "SentByI" (arity 12, Linear) 
  but no rule has such an action.

Restriction actions
===================

  restriction `method_three' references action 
    fact "MethodOk" (arity 1, Linear) 
  but no rule has such an action.

 Formula guardedness
====================

  lemma `ChannelBinding_RelayAttack' cannot be converted to a guarded formula:
    unguarded variable(s) 'pkI1', 'pkR1', 'gxy1', 'th31' in the
    subformula
      "∀ cidR pkI1 pkR1 nonce sig gxy1 th31 pk_attkey id_att th3 gxy pkI
         pkR gx gy #j.
        (AttestationAcceptedR( cidR, pkI, pkR, nonce, sig, gxy, gx, gy,
                               th3, pk_attkey, id_att
         ) @ #j) ⇒
        ((((∃ cidI pkI2 pkR2 gxy2 th32 ak #i.
             (SentByI( cidI, pkI, pkR, nonce, sig, gxy, gx, gy, th3, ak,
                       pk_attkey, id_att
              ) @ #i) ∧
             (#i < #j)) ∨
           (∃ ak #t. LeakAttKey( ak ) @ #t)) ∨
          (∃ pkI.1 #t. Compromise( pkI.1 ) @ #t)) ∨
         (∃ pkR.1 #t. Compromise( pkR.1 ) @ #t))"
    in the formula
      "∀ cidR pkI1 pkR1 nonce sig gxy1 th31 pk_attkey id_att th3 gxy pkI
         pkR gx gy #j.
        (AttestationAcceptedR( cidR, pkI, pkR, nonce, sig, gxy, gx, gy,
                               th3, pk_attkey, id_att
         ) @ #j) ⇒
        ((((∃ cidI pkI2 pkR2 gxy2 th32 ak #i.
             (SentByI( cidI, pkI, pkR, nonce, sig, gxy, gx, gy, th3, ak,
                       pk_attkey, id_att
              ) @ #i) ∧
             (#i < #j)) ∨
           (∃ ak #t. LeakAttKey( ak ) @ #t)) ∨
          (∃ pkI.1 #t. Compromise( pkI.1 ) @ #t)) ∨
         (∃ pkR.1 #t. Compromise( pkR.1 ) @ #t))"
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)

(*
WARNING: the following wellformedness checks failed!

Inexistant lemma actions
========================

  lemma `ChannelBinding_RelayAttack' references action 
    fact "AttestationAcceptedR" (arity 11, Linear) 
  but no rule has such an action.
  
  lemma `ChannelBinding_RelayAttack' references action 
    fact "Compromise" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `ChannelBinding_RelayAttack' references action 
    fact "LeakAttKey" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `ChannelBinding_RelayAttack' references action 
    fact "SentByI" (arity 12, Linear) 
  but no rule has such an action.

Restriction actions
===================

  restriction `method_three' references action 
    fact "MethodOk" (arity 1, Linear) 
  but no rule has such an action.

 Formula guardedness
====================

  lemma `ChannelBinding_RelayAttack' cannot be converted to a guarded formula:
    unguarded variable(s) 'pkI1', 'pkR1', 'gxy1', 'th31' in the
    subformula
      "∀ cidR pkI1 pkR1 nonce sig gxy1 th31 pk_attkey id_att th3 gxy pkI
         pkR gx gy #j.
        (AttestationAcceptedR( cidR, pkI, pkR, nonce, sig, gxy, gx, gy,
                               th3, pk_attkey, id_att
         ) @ #j) ⇒
        ((((∃ cidI pkI2 pkR2 gxy2 th32 ak #i.
             (SentByI( cidI, pkI, pkR, nonce, sig, gxy, gx, gy, th3, ak,
                       pk_attkey, id_att
              ) @ #i) ∧
             (#i < #j)) ∨
           (∃ ak #t. LeakAttKey( ak ) @ #t)) ∨
          (∃ pkI.1 #t. Compromise( pkI.1 ) @ #t)) ∨
         (∃ pkR.1 #t. Compromise( pkR.1 ) @ #t))"
    in the formula
      "∀ cidR pkI1 pkR1 nonce sig gxy1 th31 pk_attkey id_att th3 gxy pkI
         pkR gx gy #j.
        (AttestationAcceptedR( cidR, pkI, pkR, nonce, sig, gxy, gx, gy,
                               th3, pk_attkey, id_att
         ) @ #j) ⇒
        ((((∃ cidI pkI2 pkR2 gxy2 th32 ak #i.
             (SentByI( cidI, pkI, pkR, nonce, sig, gxy, gx, gy, th3, ak,
                       pk_attkey, id_att
              ) @ #i) ∧
             (#i < #j)) ∨
           (∃ ak #t. LeakAttKey( ak ) @ #t)) ∨
          (∃ pkI.1 #t. Compromise( pkI.1 ) @ #t)) ∨
         (∃ pkR.1 #t. Compromise( pkR.1 ) @ #t))"
*)

(*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*)
